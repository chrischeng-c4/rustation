"""CLI module for rstn v2.

Uses Click framework to implement commands that share business logic with TUI.
CLI commands are converted to AppMsg and processed through reduce().

Architecture:
    CLI Command → AppMsg → reduce() → (State, Effects) → Execute → Output

Key Principles:
    - CLI and TUI share the same reduce() function
    - Business logic lives in domain/, not here
    - Effects are executed synchronously for CLI
    - State can be saved/loaded for debugging
"""

from __future__ import annotations

import asyncio
from pathlib import Path
from typing import TYPE_CHECKING

import click
from rich.console import Console

from rstn.effect import DefaultEffectExecutor
from rstn.logging import get_logger, setup_logging
from rstn.msg import AppMsg
from rstn.reduce import reduce
from rstn.state import AppState

if TYPE_CHECKING:
    from rstn.effect import AppEffect

__all__ = ["cli", "run_cli"]

# Rich console for pretty output
console = Console()

# Logger
log = get_logger("rstn.cli")


class CliMessageSender:
    """Message sender for CLI that collects messages for processing."""

    def __init__(self) -> None:
        self.messages: list[AppMsg] = []

    async def send(self, msg: AppMsg) -> None:
        """Collect message for later processing."""
        self.messages.append(msg)


class CliEffectHandler:
    """Handles effect execution for CLI commands.

    Provides synchronous wrapper around async effect executor.
    Collects output for display to user.
    """

    def __init__(self) -> None:
        self._sender = CliMessageSender()
        self._executor = DefaultEffectExecutor(self._sender)
        self._loop: asyncio.AbstractEventLoop | None = None

    def execute_effects(self, effects: list[AppEffect]) -> list[AppMsg]:
        """Execute effects synchronously and return any resulting messages.

        Args:
            effects: Effects to execute

        Returns:
            List of messages generated by effect execution
        """
        self._sender.messages.clear()

        # Run async executor in sync context
        async def _run() -> None:
            for effect in effects:
                await self._executor.execute(effect)

        asyncio.run(_run())
        return self._sender.messages.copy()

    async def cleanup(self) -> None:
        """Cleanup resources."""
        await self._executor.cleanup()


def run_with_reduce(
    state: AppState,
    msg: AppMsg,
    handler: CliEffectHandler,
) -> tuple[AppState, list[str]]:
    """Run a message through reduce() and execute effects.

    This is the core function that ensures CLI uses the same logic as TUI.

    Args:
        state: Current application state
        msg: Message to process
        handler: Effect handler for executing side effects

    Returns:
        Tuple of (new_state, output_lines)
    """
    output: list[str] = []

    # Run through reducer
    new_state, effects = reduce(state, msg)

    # Execute effects and collect any resulting messages
    result_msgs = handler.execute_effects(effects)

    # Process result messages (might trigger more state changes)
    for result_msg in result_msgs:
        new_state, more_effects = reduce(new_state, result_msg)
        handler.execute_effects(more_effects)

    return new_state, output


# ========================================
# Main CLI Group
# ========================================


@click.group(invoke_without_command=True)
@click.option(
    "--state-file",
    type=click.Path(path_type=Path),
    default=None,
    help="Path to state file for persistence",
)
@click.option(
    "--verbose", "-v",
    is_flag=True,
    default=False,
    help="Enable verbose output",
)
@click.pass_context
def cli(ctx: click.Context, state_file: Path | None, verbose: bool) -> None:
    """rstn - Rustation Development Toolkit.

    A workflow-driven CLI for Claude Code integration.

    Examples:

        rstn                  Start the TUI (default)

        rstn prompt "hello"   Run a single prompt

        rstn specify "Add feature X"  Generate a spec

        rstn session list     List all sessions
    """
    # Setup logging
    log_file = setup_logging(verbose=verbose)
    log.info("CLI started", state_file=str(state_file) if state_file else None)

    # Ensure context object exists
    ctx.ensure_object(dict)

    # Load or create state
    if state_file and state_file.exists():
        ctx.obj["state"] = AppState.load_from_file(state_file)
        log.info("State loaded from file", path=str(state_file))
    else:
        ctx.obj["state"] = AppState()
        log.debug("Using default state")

    ctx.obj["state_file"] = state_file
    ctx.obj["verbose"] = verbose
    ctx.obj["handler"] = CliEffectHandler()
    ctx.obj["log_file"] = log_file

    # Default to TUI if no subcommand
    if ctx.invoked_subcommand is None:
        from rstn.cli.commands import tui as tui_cmd
        ctx.invoke(tui_cmd)


# Import and register subcommands
from rstn.cli.commands import (  # noqa: E402
    clarify,
    plan,
    prompt,
    session,
    specify,
    state,
    tui,
)

cli.add_command(tui, name="tui")
cli.add_command(prompt)
cli.add_command(specify)
cli.add_command(plan)
cli.add_command(clarify)
cli.add_command(session)
cli.add_command(state)


def run_cli() -> None:
    """Entry point for CLI."""
    cli(obj={})
